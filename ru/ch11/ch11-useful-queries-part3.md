# 11 Полезные запросы (III): пользовательские данные, последовательность чисел, массив, JSON и т.д.

В первых двух частях общих запросов мы представили некоторые общие методы запросов, такие как запрос цены, держатель и баланс, удерживаемый токенами ERC20. В этом разделе мы рассмотрим некоторые другие распространенные запросы.

## Таблица пользовательских данных с использованием CTE

Dune V2 в настоящее время не поддерживает пользовательские таблицы и представления. Для некоторых данных из внешних источников или небольшого количества данных, созданных вручную, мы можем рассмотреть возможность использования CTE для создания пользовательского списка данных внутри запроса. Это позволяет поддерживать пользовательские таблицы CTE с тысячами строк всего лишь с несколькими полями и они будут успешно выполняться, пока не превысят максимальный размер запроса Dune. Существует два способа настройки таблиц CTE:

Пример первого синтаксиса:
``` sql
with raydium_lp_pairs(account_key, pair_name) as (
    values
    ('58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2', 'SOL/USDC'),
    ('7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX', 'SOL/USDT'),
    ('AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA', 'RAY/SOL'),
    ('6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg', 'RAY/USDC'),
    ('DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut', 'RAY/USDT'),
    ('GaqgfieVmnmY4ZsZHHA6L5RSVzCGL3sKx4UgHBaYNy8m', 'RAY/SRMSOL'),
    ('6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj', 'STSOL/USDC'),
    ('43UHp4TuwQ7BYsaULN1qfpktmg7GWs9GpR8TDb8ovu9c', 'APEX4/USDC')
)

select * from raydium_lp_pairs
```

Пример второго синтаксиса:

``` sql
with token_plan as (
    select token_name, hook_amount from (
        values
        ('Token Type','BEP-20 on BNB Chain'),
        ('Total Token Supply','500,000,000 HOOK'),
        ('Private Sale Allocation','100,000,000 HOOK'),
        ('Private Sale Token Price','0.06 USD to 0.12 USD / HOOK'),
        ('Private Sale Amount Raised','~ 6,000,000 USD'),
        ('Binance Launchpad Sale Allocation','25,000,000 HOOK'),
        ('Binance Launchpad Sale Price','0.10 USD / HOOK'),
        ('Binance Launchpad Amount to be Raised','2,500,000 USD'),
        ('Initial Circ. Supply When Listed on Binance','50,000,000 HOOK (10.00%)')
    ) as tbl(token_name, hook_amount)
)

select * from token_plan
```

Конечно, с помощью второго синтаксиса вы можете опустить определение CTE и использовать запрос SELECT напрямую, если вам нужно вернуть только эту часть пользовательских данных.

Пример ссылки на вышеуказанный запрос:
- [https://dune.com/queries/781862](https://dune.com/queries/781862)
- [https://dune.com/queries/1650640](https://dune.com/queries/1650640)

В связи с упомянутыми выше ограничениями выполнение может не удаться, если строк слишком много. Вам придется дублировать один и тот же код CTE для каждого запроса, что относительно неудобно. Для больших объемов данных, многократно, для долгосрочного использования и т.д., вам все же следует рассмотреть возможность создания таблицы заклинаний путем отправки PR в Spellbook.

## Декодирование данных из логов

Ранее, при расчете цены токенов ERC20, мы видели пример расчета цены из логов. Давайте рассмотрим еще один пример, где нам нужно декодировать данные непосредственно из логов. Когда смарт-контракт не декодируется Dune, или таблица декодирования для соответствующего события не создана из-за неполных данных ABI, используемых при декодировании, нам может потребоваться декодировать данные запроса непосредственно из логов. В качестве примера возьмем протокол Lens, мы обнаружили, что в исходном коде смарт-контракта Lens ([Lens Core](https://github.com/lens-protocol/core)), почти каждая операция генерирует логи событий. Однако в Dune есть лишь несколько таблиц, связанных с событиями. Дальнейшее исследование выявило, что ABI, используемый при декодировании, не содержал определения этих событий. Хотя мы можем сгенерировать или попросить команду Lens предоставить полный ABI и отправить его в Dune для повторного анализа, основной момент здесь – это как извлечь данные из не декодированных логов.

В исходном коде смарт-контракта Lens мы видим определение события `FollowNFTTransferred`, [ссылка на код](https://github.com/lens-protocol/core/blob/main/contracts/libraries/Events.sol#L347). В коде также есть событие `Followed`, но декодирование усложняется аргументом массива, поэтому мы будем использовать предыдущее событие в качестве примера. Из названия события мы можем предположить, что при подписке пользователя на профиль Lens, будет создан и передан FollowNFT на адрес подписчика. Мы можем затем найти запись о транзакции, представляющую интерес. Давайте посмотрим на логи для следующей транзакции:[https://polygonscan.com/tx/0x30311c3eb32300c8e7e173c20a6d9c279c99d19334be8684038757e92545f8cf].  В браузере на странице журнала транзакций перейдите на вкладку "Logs", чтобы увидеть, что всего четыре лога событий. В некоторых случаях браузер блокчейна может отображать оригинальное название события. Просматриваемая нами транзакция Lens не показывает оригинальное название, поэтому как нам узнать, какой из них соответствует логу события `FollowNFTTransferred`? Здесь мы можем использовать сторонние инструменты для сравнения путем генерации хеша keccak256 определения события. [Keccak - 256](https://emn178.github.io/online-tools/keccak_256.html) эта страница может генерировать онлайн значение хеша Keccak - 256. Давайте очистим определение события `FollowNFTTransferred` в исходном коде до минифицированного режима (удалите имена параметров, удалите пробелы). Получаем `FollowNFTTransferred (uint256 uint256, address, адрес, uint256)`, затем вставляем его на страницу инструмента Keccak-256.

Пример ссылки на вышеуказанный запрос:
- [https://dune.com/queries/1652759](https://dune.com/queries/1652759)
- [Инструмент Keccak-256](https://emn178.github.io/online-tools/keccak_256.html)
