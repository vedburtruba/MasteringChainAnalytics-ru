# 16 Анализ блокчейна — Polygon

Платформа Dune стремительно развивается и в настоящее время поддерживает 10 основных блокчейнов, включая Layer 1 публичные сети, такие как Ethereum, BNB, Polygon, Fantom, и Layer 2 блокчейны, такие как Arbitrum и Optimism, предназначенные для расширения Ethereum. В этом уроке мы рассмотрим, как начать анализ обзора блокчейна, взяв в качестве примера блокчейн Polygon.

Девиз Polygon — «Принести Ethereum Всем». Polygon считает, что каждый может использовать Web3. Это децентрализованная платформа масштабирования Ethereum, которая позволяет разработчикам создавать масштабируемые и удобные для пользователя DApps с низкими комиссиями за транзакции, не жертвуя безопасностью.

Панель управления для этого урока: [Обзор сети Polygon](https://dune.com/sixdegree/polygOnchain-overview)<a id="jump_8"></a>

## Содержание анализа обзора блокчейна

Наша цель — всесторонне проанализировать всю сеть Polygon, чтобы понять ее текущий статус развития. Анализ включает в себя:

* **Анализ блоков**: общее количество блоков, количество блоков, добытых в минуту, общее потребление газа, среднее потребление газа, дневная (ежемесячная) тенденция количества генерируемых блоков и т. д.
* **Анализ транзакций и пользователей**: общий объем транзакций, общее количество пользователей, количество транзакций на блок, сравнение успешных и неудачных транзакций, дневная (ежемесячная) тенденция количества транзакций, дневная (ежемесячная) тенденция активных пользователей, дневная (ежемесячная) тенденция новых пользователей, сравнение новых и активных пользователей и т. д.
* **Анализ нативного токена MATIC**: общий объем циркуляции, анализ держателей, крупнейшие держатели, тенденция цены и т. д.
* **Анализ смарт-контрактов**: общее количество развернутых смарт-контрактов, дневная (ежемесячная) тенденция развертывания новых контрактов, сравнение объема транзакций для самых популярных смарт-контрактов и анализ тенденций разработки.

## Анализ количества блоков и потребления газа

### Общее количество блоков и потребление газа

Чтобы понять общее количество блоков и потребление газа в сети Polygon, мы можем написать простой SQL-запрос для получения следующей информации: общее количество блоков, метка времени генезис-блока, среднее количество новых блоков в минуту, общее потребление газа и среднее потребление газа на блок.

``` sql
select count(*) / 1e6 as blocks_count,
   min(time) as min_block_time,
   count(*) / ((to_unixtime(Now()) - to_unixtime(min(time))) / 60) as avg_block_per_minute,
   sum(gas_used * coalesce(base_fee_per_gas, 1)) / 1e18 as total_gas_used,
   avg(gas_used * coalesce(base_fee_per_gas, 1)) / 1e18 as average_gas_used
from polygon.blocks
```

Объяснение SQL:

1. Используя `to_unixtime()`, мы можем преобразовать дату и время в значения Unix Timestamp, что позволяет нам рассчитывать количество секунд между двумя датами и временем. Затем мы можем использовать это для расчета среднего количества новых блоков в минуту. Соответствующая функция — `from_unixtime()`.
2. `gas_used` представляет собой количество потребленного газа, а `base_fee_per_gas` — цена за единицу газа. Умножение их друг на друга дает стоимость газа. Нативный токен Polygon, MATIC, имеет 18 десятичных знаков, поэтому деление на 1e18 дает нам окончательную сумму MATIC.

Результаты этого запроса можно добавить в виде визуализаций типа Counter и включить в панель управления. Отображение выглядит следующим образом:

![](img/ch16_image_01.png)

Ссылка на запрос:[https://dune.com/queries/1835390](https://dune.com/queries/1835390)<a id="jump_8"></a>

### Ежедневная (ежемесячная) тенденция генерации новых блоков и потребление газа

Мы можем агрегировать по дате, чтобы рассчитать ежедневное количество сгенерированных блоков и соответствующее потребление газа. Чтобы отслеживать изменение, мы сначала определяем CTE для выполнения ежедневной статистики данных. Затем, основываясь на этом CTE, мы используем функцию окна, такую как avg`(blocks_count) over (order by rows between 6 preceding and current row)` для расчета 7-дневного скользящего среднего. SQL выглядит следующим образом:

``` sql
with block_daily as (
    select date_trunc('day', time) as block_date,
        count(*) as blocks_count,
        sum(gas_used * coalesce(base_fee_per_gas, 1)) / 1e18 as gas_used
    from polygon.blocks
    group by 1
)

select block_date,
    blocks_count,
    gas_used,
    avg(blocks_count) over (order by block_date rows between 6 preceding and current row) as ma_7_days_blocks_count,
    avg(blocks_count) over (order by block_date rows between 29 preceding and current row) as ma_30_days_blocks_count,
    avg(gas_used) over (order by block_date rows between 6 preceding and current row) as ma_7_days_gas_used
from block_daily
order by block_date
```

Добавьте два Bar Chart для запроса, отображающие "Ежедневное количество блоков, 7-дневное скользящее среднее и 30-дневное скользящее среднее количество блоков" и "Ежедневное потребление газа и 7-дневное скользящее среднее". Добавьте их на панель управления.

Создайте Fork приведенного выше запроса и немного измените его для расчета ежемесячной статистики. Также измените скользящее среднее, чтобы учесть период в 12 месяцев. Это даст нам ежемесячную тенденцию генерации новых блоков.

Визуализации этого запроса будут выглядеть следующим образом:

![](img/ch16_image_01.png)

Ссылки на запросы:
* [https://dune.com/queries/1835421](https://dune.com/queries/1835421)<a id="jump_8"></a>
* [ttps://dune.com/queries/1835445](ttps://dune.com/queries/1835445)<a id="jump_8"></a>

## Анализ транзакций и пользователей
### Общий объем транзакций и количество пользователей

Нам нужно рассчитать общее количество транзакций и общее количество уникальных адресов пользователей. CTE может быть определен для объединения адресов отправителей `from` и адресов получателей `to` с помощью UNION ALL, а затем подсчитать различные адреса. Важно отметить, что в этом анализе мы не исключаем адреса контрактов. Если вы хотите исключить адреса контрактов, вы можете добавить подзапрос для исключения этих адресов, найденных в таблице `polygon.creation_traces`. Учитывая большой объем данных, мы представим значения в миллионах (M). Добавьте визуализацию диаграммы Counter для каждой метрики и включите их в панель управления.

```sql
with transactions_detail as (
    select block_time,
        hash,
        "from" as address
    from polygon.transactions

    union all

    select block_time,
        hash,
        "to" as address
    from polygon.transactions
)

select count(distinct hash) / 1e6 as transactions_count,
    count(distinct address) / 1e6 as users_count
from transactions_detail
```

Ссылка на запрос:
* [https://dune.com/queries/1836022](https://dune.com/queries/1836022)<a id="jump_8"></a>

### Анализ ежедневных (ежемесячных) транзакций и активных пользователей

Аналогично, группируя данные по дате, мы можем генерировать отчеты об общем объеме ежедневных транзакций и количестве активных пользователей. Обобщая данные на ежемесячной основе, мы можем получить ежемесячные сведения. Ниже приведен SQL-запрос для ежедневной агрегации:

```sql
with transactions_detail as (
    select block_time,
        hash,
        "from" as address
    from polygon.transactions

    union all

    select block_time,
        hash,
        "to" as address
    from polygon.transactions
)

select date_trunc('day', block_time) as block_date,
    count(distinct hash) as transactions_count,
    count(distinct address) as users_count
from transactions_detail
group by 1
order by 1
```

Добавьте гистограмму для как для ежедневных, так и для ежемесячных данных о транзакциях, отображающую количество транзакций и количество активных пользователей. Вы можете использовать вторичную ось Y для количества активных пользователей и выбрать либо диаграмму Линии, либо диаграмму Площади. Полученная визуализация на панели управления будет следующей:

![](img/ch16_image_04.png)

Ссылка на запрос:
* [https://dune.com/queries/1836744](https://dune.com/queries/1836744)<a id="jump_8"></a>
* [ttps://dune.com/queries/1836854](https://dune.com/queries/1836854)<a id="jump_8"></a>

### Анализ статистики пользователей
Для этих двух запросов мы можем добавить следующие визуализации:

1. Гистограмма: отображает ежедневное (или ежемесячное) количество активных и новых пользователей. Поскольку доля новых пользователей относительно невелика, установите ее для использования вторичной оси Y.
2. Диаграмма Площади: сравнивает долю новых и существующих пользователей.

Добавление этих визуализаций на панель управления приведет к следующему отображению:

![](img/ch16_image_04.png)

Ссылка на запрос:
* [https://dune.com/queries/1836744](https://dune.com/queries/1836744)<a id="jump_8"></a>
* [ttps://dune.com/queries/1836854](https://dune.com/queries/1836854)<a id="jump_8"></a>
## Анализ нативного токена
### Тенденция цены MATIC

Заклинания Dune `prices.usd` предоставляют цену токенов сети Polygon, включая нативный токен MATIC. Поэтому мы можем напрямую рассчитывать среднюю цену на ежедневной основе.

``` sql
select date_trunc('day', minute) as block_date,
    avg(price) as price
from prices.usd
where blockchain = 'polygon'
    and symbol = 'MATIC'
group by 1
order by 1
```

Поскольку результаты запроса отсортированы в возрастающем порядке по дате, последняя запись представляет собой среднюю цену на наиболее свежую дату, которую можно считать "текущей ценой". Мы можем сгенерировать график Counter для этого, установив значение "Номер строки" на "-1", чтобы получить значение из последней строки. Кроме того, мы можем добавить линию для отображения ежедневной средней цены токена MATIC. После добавления этих графиков на панель управления, отображение будет выглядеть следующим образом:

![](img/ch16_image_05.png)

Ссылка на запрос:
* [https://dune.com/queries/1836933](https://dune.com/queries/1836933)<a id="jump_8"></a>

### Адреса с самыми большими ходингами токена MATIC

Для нас представляют интерес адреса с самыми большими ходингами токена MATIC, поскольку они часто имеют потенциал влиять на изменения цены токена. Следующий запрос извлекает 1000 лучших адресов. `MATIC` является нативным токеном сети Polygon, и сведения о его переводах хранятся в таблице `polygon.traces`. Обратите внимание, что в этом запросе мы не различаем между контрактными и неконтрактными адресами. Из-за низких комиссий за транзакции газа в сети Polygon мы опустили расчет потребления газа по соображениям производительности.

``` sql
with polygon_transfer_raw as (
    select "from" as address, (-1) * cast(value as decimal) as amount
    from polygon.traces
    where call_type = 'call'
        and success = true
        and value > uint256 '0'
    
    union all
    
    select "to" as address, cast(value as decimal) as amount
    from polygon.traces
    where call_type = 'call'
        and success = true
        and value > uint256 '0'
)

select address,
    sum(amount) / 1e18 as amount
from polygon_transfer_raw
group by 1
order by 2 desc
limit 1000
```

Соображения по поводу вышеуказанного запроса: значение в `polygon.traces` имеет тип `uint256`, который является пользовательским типом в Dune SQL. Если напрямую сравнивать его с числовым значением 0, произойдет ошибка несовпадения типов, которая помешает сравнению. Поэтому мы используем синтаксис, такой как `uint256 '0'`, чтобы преобразовать значение 0 в один и тот же тип для сравнения. В качестве альтернативы, вы можете использовать функции преобразования типов, такие как `cast(0 as uint256)`. Вы также можете преобразовать `value` в double, decimal, bigint или другие типы перед сравнением, но в таких случаях следует учитывать потенциальные проблемы переполнения данных.

Мы можем далее проанализировать распределение ходингов токена MATIC среди 1000 лучших адресов на основе вышеуказанного запроса. Мы можем создать ответвление от существующего запроса и изменить его.

``` sql
with polygon_transfer_raw as (
    select "from" as address, (-1) * cast(value as decimal) as amount
    from polygon.traces
    where call_type = 'call'
        and success = true
        and value > uint256 '0'
    
    union all
    
    select "to" as address, cast(value as decimal) as amount
    from polygon.traces
    where call_type = 'call'
        and success = true
        and value > uint256 '0'
)

select address,
    sum(amount) / 1e18 as amount
from polygon_transfer_raw
group by 1
order by 2 desc
limit 1000
```

Сгенерируйте график столбчатой диаграммы и круговую диаграмму для вышеуказанных двух запросов соответственно. Добавьте их на панель управления, и отображение выглядит следующим образом:

![](img/ch16_image_06.png)

Ссылки на запросы:
* [https://dune.com/queries/1837749](https://dune.com/queries/1837749)<a id="jump_8"></a>
* [ttps://dune.com/queries/1837150](ttps://dune.com/queries/1837150)<a id="jump_8"></a>
* [ttps://dune.com/queries/1837781](ttps://dune.com/queries/1837781)<a id="jump_8"></a>

## Анализ Умных Контрактов

### Количество Созданных и Уничтоженных Контрактов

``` sql
select type,
    count(*) / 1e6 as transactions_count
from polygon.traces
where type in ('create', 'suicide')
    and block_time >= date('2023-01-01') -- Date conditions are added here for performance considerations
group by 1
order by 1
```

Поскольку мы ограничили значения `type` и указали порядок сортировки, мы можем гарантировать, что будет возвращено две записи и их порядок фиксирован. Следовательно, мы можем генерировать визуализации типа Counter для значений в первой и второй строках соответственно.

Ссылка на запрос:
* [https://dune.com/queries/1837749](https://dune.com/queries/1837749)<a id="jump_8"></a>

### Ежедневное (Ежемесячное) Количество Созданных и Уничтоженных Контрактов

Мы можем рассчитать ежедневное (ежемесячное) количество вновь созданных и уничтоженных контрактов по дате. Учитывая, что совокупное количество также ценно, мы сначала используем CTE для расчета ежедневного количества, а затем используем оконную функцию `sum() over (partition by type order by block_date)` для расчета совокупного количества по дате. `partition by type` используется для указания отдельных агрегаций на основе типа контракта.

``` sql
with polygon_contracts as (
    select date_trunc('day', block_time) as block_date,
        type,
        count(*) as transactions_count
    from polygon.traces
    where type in ('create', 'suicide')
    group by 1, 2
)

select block_date, 
    contract_address,
    count(*) as transaction_count
from polygon.transactions t
inner join top_contracts c on t."to" = c.contract_address
group by 1, 2
order by 1, 2
```

Мы сначала запрашиваем 20 самых умных контрактов с наибольшим историческим объемом транзакций. Затем мы рассчитываем ежедневный объем транзакций для этих умных контрактов. Мы добавляем три разных типа визуализаций для запроса:

1. Столбчатая диаграмма: отображает ежедневный объем транзакций для разных умных контрактов, сложенных вместе.
2. Площадная диаграмма: отображает ежедневный объем транзакций для разных умных контрактов, сложенных вместе. Мы установили "Нормализовать к проценту", чтобы настроить диаграмму для отображения в процентах.
3. Круговая диаграмма: сравнивает совокупные проценты объема транзакций для этих 20 лучших умных контрактов.

После добавления этих диаграмм на панель управления отображается следующий результат:

![](img/ch16_image_09.png)

Ссылка на запрос:
* [https://dune.com/queries/1838060](https://dune.com/queries/1838060)<a id="jump_8"></a>

### Самые активные умные контракты за последние 30 дней

В дополнение к анализу всех исторических данных о транзакциях, мы также можем выполнить простой анализ самых активных умных контрактов в последнее время. Например, мы можем проанализировать 50 самых активных умных контрактов за последние 30 дней.

``` sql
select "to" as contract_address,
    '<a href=https://polygonscan.com/address/' || cast("to" as varchar) || ' target=_blank>PolygonScan</a>' as link,
    count(*) as transaction_count
from polygon.transactions
where block_time >= now() - interval '30' day
group by 1, 2
order by 3 desc
limit 50
```

Поскольку это недавно активные проекты, они могли быть недавно развернуты и запущены. Поэтому мы добавили гиперссылки на запрос и создали таблицу.
